// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpc.proto

package grpc

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	tspb "github.com/libtsdb/libtsdb-go/tspb"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Error struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{0}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(m, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

type PingReq struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingReq) Reset()         { *m = PingReq{} }
func (m *PingReq) String() string { return proto.CompactTextString(m) }
func (*PingReq) ProtoMessage()    {}
func (*PingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{1}
}
func (m *PingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingReq.Merge(m, src)
}
func (m *PingReq) XXX_Size() int {
	return m.Size()
}
func (m *PingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PingReq.DiscardUnknown(m)
}

var xxx_messageInfo_PingReq proto.InternalMessageInfo

type PingRes struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingRes) Reset()         { *m = PingRes{} }
func (m *PingRes) String() string { return proto.CompactTextString(m) }
func (*PingRes) ProtoMessage()    {}
func (*PingRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{2}
}
func (m *PingRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingRes.Merge(m, src)
}
func (m *PingRes) XXX_Size() int {
	return m.Size()
}
func (m *PingRes) XXX_DiscardUnknown() {
	xxx_messageInfo_PingRes.DiscardUnknown(m)
}

var xxx_messageInfo_PingRes proto.InternalMessageInfo

// raw, no prepare
type WritePointsReq struct {
	Int                  []tspb.PointIntTagged    `protobuf:"bytes,1,rep,name=int,proto3" json:"int"`
	Double               []tspb.PointDoubleTagged `protobuf:"bytes,2,rep,name=double,proto3" json:"double"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *WritePointsReq) Reset()         { *m = WritePointsReq{} }
func (m *WritePointsReq) String() string { return proto.CompactTextString(m) }
func (*WritePointsReq) ProtoMessage()    {}
func (*WritePointsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{3}
}
func (m *WritePointsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WritePointsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WritePointsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WritePointsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WritePointsReq.Merge(m, src)
}
func (m *WritePointsReq) XXX_Size() int {
	return m.Size()
}
func (m *WritePointsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WritePointsReq.DiscardUnknown(m)
}

var xxx_messageInfo_WritePointsReq proto.InternalMessageInfo

type WritePointsRes struct {
	Error                *Error   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WritePointsRes) Reset()         { *m = WritePointsRes{} }
func (m *WritePointsRes) String() string { return proto.CompactTextString(m) }
func (*WritePointsRes) ProtoMessage()    {}
func (*WritePointsRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{4}
}
func (m *WritePointsRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WritePointsRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WritePointsRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WritePointsRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WritePointsRes.Merge(m, src)
}
func (m *WritePointsRes) XXX_Size() int {
	return m.Size()
}
func (m *WritePointsRes) XXX_DiscardUnknown() {
	xxx_messageInfo_WritePointsRes.DiscardUnknown(m)
}

var xxx_messageInfo_WritePointsRes proto.InternalMessageInfo

type WriteSeriesReq struct {
	Int                  []tspb.SeriesIntTagged    `protobuf:"bytes,1,rep,name=int,proto3" json:"int"`
	Double               []tspb.SeriesDoubleTagged `protobuf:"bytes,2,rep,name=double,proto3" json:"double"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *WriteSeriesReq) Reset()         { *m = WriteSeriesReq{} }
func (m *WriteSeriesReq) String() string { return proto.CompactTextString(m) }
func (*WriteSeriesReq) ProtoMessage()    {}
func (*WriteSeriesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{5}
}
func (m *WriteSeriesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteSeriesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteSeriesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteSeriesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteSeriesReq.Merge(m, src)
}
func (m *WriteSeriesReq) XXX_Size() int {
	return m.Size()
}
func (m *WriteSeriesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteSeriesReq.DiscardUnknown(m)
}

var xxx_messageInfo_WriteSeriesReq proto.InternalMessageInfo

type WriteSeriesRes struct {
	Error                Error    `protobuf:"bytes,1,opt,name=error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WriteSeriesRes) Reset()         { *m = WriteSeriesRes{} }
func (m *WriteSeriesRes) String() string { return proto.CompactTextString(m) }
func (*WriteSeriesRes) ProtoMessage()    {}
func (*WriteSeriesRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{6}
}
func (m *WriteSeriesRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteSeriesRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteSeriesRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteSeriesRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteSeriesRes.Merge(m, src)
}
func (m *WriteSeriesRes) XXX_Size() int {
	return m.Size()
}
func (m *WriteSeriesRes) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteSeriesRes.DiscardUnknown(m)
}

var xxx_messageInfo_WriteSeriesRes proto.InternalMessageInfo

// prepare
type PrepareSeriesReq struct {
	Series               []tspb.EmptySeries `protobuf:"bytes,1,rep,name=series,proto3" json:"series"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PrepareSeriesReq) Reset()         { *m = PrepareSeriesReq{} }
func (m *PrepareSeriesReq) String() string { return proto.CompactTextString(m) }
func (*PrepareSeriesReq) ProtoMessage()    {}
func (*PrepareSeriesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{7}
}
func (m *PrepareSeriesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareSeriesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareSeriesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareSeriesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareSeriesReq.Merge(m, src)
}
func (m *PrepareSeriesReq) XXX_Size() int {
	return m.Size()
}
func (m *PrepareSeriesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareSeriesReq.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareSeriesReq proto.InternalMessageInfo

type PrepareSeriesRes struct {
	Series               []uint64 `protobuf:"varint,1,rep,packed,name=series,proto3" json:"series,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrepareSeriesRes) Reset()         { *m = PrepareSeriesRes{} }
func (m *PrepareSeriesRes) String() string { return proto.CompactTextString(m) }
func (*PrepareSeriesRes) ProtoMessage()    {}
func (*PrepareSeriesRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{8}
}
func (m *PrepareSeriesRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareSeriesRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareSeriesRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareSeriesRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareSeriesRes.Merge(m, src)
}
func (m *PrepareSeriesRes) XXX_Size() int {
	return m.Size()
}
func (m *PrepareSeriesRes) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareSeriesRes.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareSeriesRes proto.InternalMessageInfo

type PreparedPointInt struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	T                    int64    `protobuf:"varint,2,opt,name=T,proto3" json:"T,omitempty"`
	V                    int64    `protobuf:"varint,3,opt,name=V,proto3" json:"V,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreparedPointInt) Reset()         { *m = PreparedPointInt{} }
func (m *PreparedPointInt) String() string { return proto.CompactTextString(m) }
func (*PreparedPointInt) ProtoMessage()    {}
func (*PreparedPointInt) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{9}
}
func (m *PreparedPointInt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreparedPointInt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreparedPointInt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreparedPointInt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreparedPointInt.Merge(m, src)
}
func (m *PreparedPointInt) XXX_Size() int {
	return m.Size()
}
func (m *PreparedPointInt) XXX_DiscardUnknown() {
	xxx_messageInfo_PreparedPointInt.DiscardUnknown(m)
}

var xxx_messageInfo_PreparedPointInt proto.InternalMessageInfo

type PreparedPointDouble struct {
	Id                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	T                    int64    `protobuf:"varint,2,opt,name=T,proto3" json:"T,omitempty"`
	V                    float64  `protobuf:"fixed64,3,opt,name=V,proto3" json:"V,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PreparedPointDouble) Reset()         { *m = PreparedPointDouble{} }
func (m *PreparedPointDouble) String() string { return proto.CompactTextString(m) }
func (*PreparedPointDouble) ProtoMessage()    {}
func (*PreparedPointDouble) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{10}
}
func (m *PreparedPointDouble) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreparedPointDouble) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreparedPointDouble.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreparedPointDouble) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreparedPointDouble.Merge(m, src)
}
func (m *PreparedPointDouble) XXX_Size() int {
	return m.Size()
}
func (m *PreparedPointDouble) XXX_DiscardUnknown() {
	xxx_messageInfo_PreparedPointDouble.DiscardUnknown(m)
}

var xxx_messageInfo_PreparedPointDouble proto.InternalMessageInfo

type WritePreparedPointsReq struct {
	Int                  []PreparedPointInt    `protobuf:"bytes,1,rep,name=int,proto3" json:"int"`
	Double               []PreparedPointDouble `protobuf:"bytes,2,rep,name=double,proto3" json:"double"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *WritePreparedPointsReq) Reset()         { *m = WritePreparedPointsReq{} }
func (m *WritePreparedPointsReq) String() string { return proto.CompactTextString(m) }
func (*WritePreparedPointsReq) ProtoMessage()    {}
func (*WritePreparedPointsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{11}
}
func (m *WritePreparedPointsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WritePreparedPointsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WritePreparedPointsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WritePreparedPointsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WritePreparedPointsReq.Merge(m, src)
}
func (m *WritePreparedPointsReq) XXX_Size() int {
	return m.Size()
}
func (m *WritePreparedPointsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WritePreparedPointsReq.DiscardUnknown(m)
}

var xxx_messageInfo_WritePreparedPointsReq proto.InternalMessageInfo

type WritePreparedPointsRes struct {
	Error                Error    `protobuf:"bytes,1,opt,name=error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WritePreparedPointsRes) Reset()         { *m = WritePreparedPointsRes{} }
func (m *WritePreparedPointsRes) String() string { return proto.CompactTextString(m) }
func (*WritePreparedPointsRes) ProtoMessage()    {}
func (*WritePreparedPointsRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{12}
}
func (m *WritePreparedPointsRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WritePreparedPointsRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WritePreparedPointsRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WritePreparedPointsRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WritePreparedPointsRes.Merge(m, src)
}
func (m *WritePreparedPointsRes) XXX_Size() int {
	return m.Size()
}
func (m *WritePreparedPointsRes) XXX_DiscardUnknown() {
	xxx_messageInfo_WritePreparedPointsRes.DiscardUnknown(m)
}

var xxx_messageInfo_WritePreparedPointsRes proto.InternalMessageInfo

type WritePreparedSeriesReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WritePreparedSeriesReq) Reset()         { *m = WritePreparedSeriesReq{} }
func (m *WritePreparedSeriesReq) String() string { return proto.CompactTextString(m) }
func (*WritePreparedSeriesReq) ProtoMessage()    {}
func (*WritePreparedSeriesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{13}
}
func (m *WritePreparedSeriesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WritePreparedSeriesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WritePreparedSeriesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WritePreparedSeriesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WritePreparedSeriesReq.Merge(m, src)
}
func (m *WritePreparedSeriesReq) XXX_Size() int {
	return m.Size()
}
func (m *WritePreparedSeriesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WritePreparedSeriesReq.DiscardUnknown(m)
}

var xxx_messageInfo_WritePreparedSeriesReq proto.InternalMessageInfo

type WritePreparedSeriesRes struct {
	Error                Error    `protobuf:"bytes,1,opt,name=error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WritePreparedSeriesRes) Reset()         { *m = WritePreparedSeriesRes{} }
func (m *WritePreparedSeriesRes) String() string { return proto.CompactTextString(m) }
func (*WritePreparedSeriesRes) ProtoMessage()    {}
func (*WritePreparedSeriesRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{14}
}
func (m *WritePreparedSeriesRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WritePreparedSeriesRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WritePreparedSeriesRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WritePreparedSeriesRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WritePreparedSeriesRes.Merge(m, src)
}
func (m *WritePreparedSeriesRes) XXX_Size() int {
	return m.Size()
}
func (m *WritePreparedSeriesRes) XXX_DiscardUnknown() {
	xxx_messageInfo_WritePreparedSeriesRes.DiscardUnknown(m)
}

var xxx_messageInfo_WritePreparedSeriesRes proto.InternalMessageInfo

type WritePreparedSeriesColumnarReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WritePreparedSeriesColumnarReq) Reset()         { *m = WritePreparedSeriesColumnarReq{} }
func (m *WritePreparedSeriesColumnarReq) String() string { return proto.CompactTextString(m) }
func (*WritePreparedSeriesColumnarReq) ProtoMessage()    {}
func (*WritePreparedSeriesColumnarReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{15}
}
func (m *WritePreparedSeriesColumnarReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WritePreparedSeriesColumnarReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WritePreparedSeriesColumnarReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WritePreparedSeriesColumnarReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WritePreparedSeriesColumnarReq.Merge(m, src)
}
func (m *WritePreparedSeriesColumnarReq) XXX_Size() int {
	return m.Size()
}
func (m *WritePreparedSeriesColumnarReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WritePreparedSeriesColumnarReq.DiscardUnknown(m)
}

var xxx_messageInfo_WritePreparedSeriesColumnarReq proto.InternalMessageInfo

type WritePreparedSeriesColumnarRes struct {
	Error                Error    `protobuf:"bytes,1,opt,name=error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WritePreparedSeriesColumnarRes) Reset()         { *m = WritePreparedSeriesColumnarRes{} }
func (m *WritePreparedSeriesColumnarRes) String() string { return proto.CompactTextString(m) }
func (*WritePreparedSeriesColumnarRes) ProtoMessage()    {}
func (*WritePreparedSeriesColumnarRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_77a6da22d6a3feb1, []int{16}
}
func (m *WritePreparedSeriesColumnarRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WritePreparedSeriesColumnarRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WritePreparedSeriesColumnarRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WritePreparedSeriesColumnarRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WritePreparedSeriesColumnarRes.Merge(m, src)
}
func (m *WritePreparedSeriesColumnarRes) XXX_Size() int {
	return m.Size()
}
func (m *WritePreparedSeriesColumnarRes) XXX_DiscardUnknown() {
	xxx_messageInfo_WritePreparedSeriesColumnarRes.DiscardUnknown(m)
}

var xxx_messageInfo_WritePreparedSeriesColumnarRes proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Error)(nil), "xkrpc.Error")
	proto.RegisterType((*PingReq)(nil), "xkrpc.PingReq")
	proto.RegisterType((*PingRes)(nil), "xkrpc.PingRes")
	proto.RegisterType((*WritePointsReq)(nil), "xkrpc.WritePointsReq")
	proto.RegisterType((*WritePointsRes)(nil), "xkrpc.WritePointsRes")
	proto.RegisterType((*WriteSeriesReq)(nil), "xkrpc.WriteSeriesReq")
	proto.RegisterType((*WriteSeriesRes)(nil), "xkrpc.WriteSeriesRes")
	proto.RegisterType((*PrepareSeriesReq)(nil), "xkrpc.PrepareSeriesReq")
	proto.RegisterType((*PrepareSeriesRes)(nil), "xkrpc.PrepareSeriesRes")
	proto.RegisterType((*PreparedPointInt)(nil), "xkrpc.PreparedPointInt")
	proto.RegisterType((*PreparedPointDouble)(nil), "xkrpc.PreparedPointDouble")
	proto.RegisterType((*WritePreparedPointsReq)(nil), "xkrpc.WritePreparedPointsReq")
	proto.RegisterType((*WritePreparedPointsRes)(nil), "xkrpc.WritePreparedPointsRes")
	proto.RegisterType((*WritePreparedSeriesReq)(nil), "xkrpc.WritePreparedSeriesReq")
	proto.RegisterType((*WritePreparedSeriesRes)(nil), "xkrpc.WritePreparedSeriesRes")
	proto.RegisterType((*WritePreparedSeriesColumnarReq)(nil), "xkrpc.WritePreparedSeriesColumnarReq")
	proto.RegisterType((*WritePreparedSeriesColumnarRes)(nil), "xkrpc.WritePreparedSeriesColumnarRes")
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor_77a6da22d6a3feb1) }

var fileDescriptor_77a6da22d6a3feb1 = []byte{
	// 593 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0xdf, 0x8e, 0xd2, 0x40,
	0x14, 0xc6, 0x19, 0x28, 0x90, 0x1d, 0x56, 0xa2, 0xb3, 0x2e, 0xdb, 0xd4, 0x88, 0x58, 0x63, 0x42,
	0x54, 0x4a, 0x82, 0x7f, 0x62, 0x4c, 0x34, 0x11, 0xdc, 0x0b, 0xbd, 0x22, 0x15, 0x57, 0xe3, 0x1d,
	0xa5, 0x63, 0xb7, 0x59, 0xe8, 0xd4, 0x99, 0x12, 0xf5, 0xda, 0x47, 0xf0, 0xa5, 0xb8, 0xf4, 0x09,
	0x8c, 0xf2, 0x24, 0x66, 0x66, 0x5a, 0x76, 0xda, 0x2d, 0x95, 0xf5, 0x0a, 0x4e, 0xcf, 0xf7, 0x7d,
	0xf3, 0xeb, 0x9c, 0x61, 0x80, 0x7b, 0x34, 0x9c, 0x59, 0x21, 0x25, 0x11, 0x41, 0xd5, 0xaf, 0x67,
	0x34, 0x9c, 0x19, 0x3d, 0xcf, 0x8f, 0x4e, 0x97, 0x8e, 0x35, 0x23, 0x8b, 0xbe, 0x47, 0x3c, 0xd2,
	0x17, 0x5d, 0x67, 0xf9, 0x49, 0x54, 0xa2, 0x10, 0xdf, 0xa4, 0xcb, 0xb8, 0xaf, 0xc8, 0xe7, 0xbe,
	0x13, 0x31, 0xd7, 0x49, 0x3e, 0x7b, 0x1e, 0xe9, 0x47, 0x2c, 0x74, 0xfa, 0x11, 0x93, 0x62, 0xf3,
	0x36, 0xac, 0x1e, 0x53, 0x4a, 0x28, 0xd2, 0x61, 0x7d, 0x81, 0x19, 0x9b, 0x7a, 0x58, 0x07, 0x1d,
	0xd0, 0xdd, 0xb3, 0x93, 0xd2, 0xbc, 0x03, 0xeb, 0x63, 0x3f, 0xf0, 0x6c, 0xfc, 0x79, 0x17, 0x11,
	0x2b, 0x10, 0x2d, 0x61, 0xf3, 0x3d, 0xf5, 0x23, 0x3c, 0x26, 0x7e, 0x10, 0x31, 0x1e, 0xf8, 0x00,
	0x56, 0xfc, 0x20, 0xd2, 0x41, 0xa7, 0xd2, 0x6d, 0x0c, 0xae, 0x5b, 0x9c, 0xcd, 0x12, 0xdd, 0xd7,
	0x41, 0x34, 0x99, 0x7a, 0x1e, 0x76, 0x87, 0xda, 0xea, 0xd7, 0xad, 0x92, 0xcd, 0x65, 0xe8, 0x31,
	0xac, 0xb9, 0x64, 0xe9, 0xcc, 0xb1, 0x5e, 0x16, 0x86, 0x23, 0xc5, 0xf0, 0x4a, 0x34, 0x52, 0x9e,
	0x58, 0x6c, 0x3e, 0xca, 0x2c, 0xcb, 0x90, 0x09, 0xab, 0x98, 0xbf, 0xb5, 0x00, 0x6c, 0x0c, 0xf6,
	0x2d, 0xb1, 0xd1, 0x96, 0xd8, 0x09, 0x5b, 0xb6, 0xcc, 0x2f, 0xb1, 0xeb, 0x2d, 0xa6, 0x3e, 0x16,
	0xb0, 0x3d, 0x15, 0xf6, 0x50, 0xae, 0x2d, 0xbb, 0xb9, 0xb4, 0x4f, 0x32, 0xb4, 0xba, 0xea, 0x28,
	0xc0, 0x7d, 0x96, 0x59, 0x98, 0xa1, 0x6e, 0x01, 0x6e, 0x6c, 0x8e, 0xa1, 0x47, 0xf0, 0xea, 0x98,
	0xe2, 0x70, 0x4a, 0x15, 0xec, 0x3e, 0xac, 0x31, 0x51, 0xc4, 0xe4, 0xd7, 0x24, 0xc7, 0xf1, 0x22,
	0x8c, 0xbe, 0x49, 0x55, 0x02, 0x20, 0x65, 0xe6, 0xbd, 0x0b, 0x21, 0x0c, 0xb5, 0x52, 0x21, 0xda,
	0x46, 0xfb, 0x62, 0xa3, 0x75, 0x93, 0xb9, 0xa1, 0x26, 0x2c, 0xfb, 0xae, 0x60, 0xd5, 0xec, 0xb2,
	0xef, 0xa2, 0x7d, 0x08, 0x26, 0x7a, 0xb9, 0x03, 0xba, 0x15, 0x1b, 0x4c, 0x78, 0x75, 0xa2, 0x57,
	0x64, 0x75, 0x62, 0xbe, 0x84, 0x07, 0x29, 0xbf, 0xdc, 0x97, 0x5d, 0x23, 0x00, 0x8f, 0xf8, 0x0e,
	0x60, 0x4b, 0xce, 0x57, 0x0d, 0x8a, 0x5f, 0x5d, 0x99, 0xd8, 0x51, 0xbc, 0x6d, 0x59, 0x5e, 0x75,
	0x66, 0x4f, 0x33, 0x33, 0x33, 0xf2, 0x3c, 0x92, 0x31, 0x33, 0xb5, 0xe1, 0x16, 0x88, 0xcb, 0x4c,
	0x4f, 0xcf, 0x64, 0x6c, 0x66, 0x78, 0x21, 0xfd, 0x7f, 0xce, 0x46, 0x07, 0xb6, 0x73, 0x32, 0x46,
	0x64, 0xbe, 0x5c, 0x04, 0x53, 0xca, 0x57, 0x79, 0xf3, 0x0f, 0xc5, 0x25, 0x56, 0x1b, 0xfc, 0xd0,
	0x60, 0xfd, 0x03, 0x0e, 0x4f, 0x49, 0x70, 0x86, 0xba, 0x50, 0xe3, 0x97, 0x03, 0x6a, 0x26, 0xbb,
	0x29, 0xaf, 0x13, 0x23, 0x5d, 0x33, 0xb3, 0x84, 0x9e, 0xc3, 0x86, 0xf2, 0x53, 0x45, 0x87, 0xb1,
	0x20, 0x7d, 0x6b, 0x18, 0xb9, 0x8f, 0x55, 0xbb, 0x04, 0x4f, 0xdb, 0x37, 0x9b, 0x69, 0xe4, 0x3e,
	0xe6, 0xf6, 0x11, 0xbc, 0x92, 0x3a, 0xf8, 0x28, 0x73, 0x64, 0xce, 0x23, 0xb6, 0x34, 0x78, 0xc8,
	0x3b, 0x78, 0x90, 0x73, 0x10, 0xd0, 0xcd, 0x14, 0x73, 0xf6, 0xa4, 0x1a, 0x85, 0xed, 0xbc, 0xd8,
	0x98, 0x30, 0xd7, 0x77, 0xce, 0x59, 0xd8, 0xe6, 0xb1, 0x0b, 0x78, 0xa3, 0x60, 0xe4, 0xe8, 0xee,
	0x76, 0xbf, 0x72, 0x70, 0x8c, 0x9d, 0x64, 0xcc, 0x2c, 0x0d, 0x5b, 0xab, 0x3f, 0xed, 0xd2, 0x6a,
	0xdd, 0x06, 0x3f, 0xd7, 0x6d, 0xf0, 0x7b, 0xdd, 0x06, 0x1f, 0x35, 0x8f, 0x86, 0x33, 0xa7, 0x26,
	0xfe, 0x8d, 0x1e, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x53, 0x03, 0xe6, 0x26, 0xfd, 0x06, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// XephonkClient is the client API for Xephonk service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type XephonkClient interface {
	Ping(ctx context.Context, in *PingReq, opts ...grpc.CallOption) (*PingRes, error)
	// WritePoints is the most verbose one, but requires least effort on client side, just stream in point with tag
	WritePoints(ctx context.Context, in *WritePointsReq, opts ...grpc.CallOption) (*WritePointsRes, error)
	// WriteSereis groups points of same series together to reduce cost of duplicating meta
	WriteSeries(ctx context.Context, in *WriteSeriesReq, opts ...grpc.CallOption) (*WriteSeriesRes, error)
	// PrepareSeries gives each series a unique id, that can be used in this connection to omit passing full meta
	PrepareSeries(ctx context.Context, in *PrepareSeriesReq, opts ...grpc.CallOption) (*PrepareSeriesRes, error)
	// WritePreparedPoints don't group points by series, but only prepared id is needed, not need to pass full meta
	WritePreparedPoints(ctx context.Context, in *WritePreparedPointsReq, opts ...grpc.CallOption) (*WritePreparedPointsRes, error)
	// WritePreparedSeries not only use id for series, but also group points by series
	WritePreparedSeries(ctx context.Context, in *WritePreparedSeriesReq, opts ...grpc.CallOption) (*WritePreparedSeriesRes, error)
	// WritePreparedSeriesColumnar use columnar format so points in one series can be compressed by protobuf
	WritePreparedSeriesColumnar(ctx context.Context, in *WritePreparedSeriesColumnarReq, opts ...grpc.CallOption) (*WritePreparedSeriesColumnarRes, error)
}

type xephonkClient struct {
	cc *grpc.ClientConn
}

func NewXephonkClient(cc *grpc.ClientConn) XephonkClient {
	return &xephonkClient{cc}
}

func (c *xephonkClient) Ping(ctx context.Context, in *PingReq, opts ...grpc.CallOption) (*PingRes, error) {
	out := new(PingRes)
	err := c.cc.Invoke(ctx, "/xkrpc.Xephonk/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xephonkClient) WritePoints(ctx context.Context, in *WritePointsReq, opts ...grpc.CallOption) (*WritePointsRes, error) {
	out := new(WritePointsRes)
	err := c.cc.Invoke(ctx, "/xkrpc.Xephonk/WritePoints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xephonkClient) WriteSeries(ctx context.Context, in *WriteSeriesReq, opts ...grpc.CallOption) (*WriteSeriesRes, error) {
	out := new(WriteSeriesRes)
	err := c.cc.Invoke(ctx, "/xkrpc.Xephonk/WriteSeries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xephonkClient) PrepareSeries(ctx context.Context, in *PrepareSeriesReq, opts ...grpc.CallOption) (*PrepareSeriesRes, error) {
	out := new(PrepareSeriesRes)
	err := c.cc.Invoke(ctx, "/xkrpc.Xephonk/PrepareSeries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xephonkClient) WritePreparedPoints(ctx context.Context, in *WritePreparedPointsReq, opts ...grpc.CallOption) (*WritePreparedPointsRes, error) {
	out := new(WritePreparedPointsRes)
	err := c.cc.Invoke(ctx, "/xkrpc.Xephonk/WritePreparedPoints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xephonkClient) WritePreparedSeries(ctx context.Context, in *WritePreparedSeriesReq, opts ...grpc.CallOption) (*WritePreparedSeriesRes, error) {
	out := new(WritePreparedSeriesRes)
	err := c.cc.Invoke(ctx, "/xkrpc.Xephonk/WritePreparedSeries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xephonkClient) WritePreparedSeriesColumnar(ctx context.Context, in *WritePreparedSeriesColumnarReq, opts ...grpc.CallOption) (*WritePreparedSeriesColumnarRes, error) {
	out := new(WritePreparedSeriesColumnarRes)
	err := c.cc.Invoke(ctx, "/xkrpc.Xephonk/WritePreparedSeriesColumnar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// XephonkServer is the server API for Xephonk service.
type XephonkServer interface {
	Ping(context.Context, *PingReq) (*PingRes, error)
	// WritePoints is the most verbose one, but requires least effort on client side, just stream in point with tag
	WritePoints(context.Context, *WritePointsReq) (*WritePointsRes, error)
	// WriteSereis groups points of same series together to reduce cost of duplicating meta
	WriteSeries(context.Context, *WriteSeriesReq) (*WriteSeriesRes, error)
	// PrepareSeries gives each series a unique id, that can be used in this connection to omit passing full meta
	PrepareSeries(context.Context, *PrepareSeriesReq) (*PrepareSeriesRes, error)
	// WritePreparedPoints don't group points by series, but only prepared id is needed, not need to pass full meta
	WritePreparedPoints(context.Context, *WritePreparedPointsReq) (*WritePreparedPointsRes, error)
	// WritePreparedSeries not only use id for series, but also group points by series
	WritePreparedSeries(context.Context, *WritePreparedSeriesReq) (*WritePreparedSeriesRes, error)
	// WritePreparedSeriesColumnar use columnar format so points in one series can be compressed by protobuf
	WritePreparedSeriesColumnar(context.Context, *WritePreparedSeriesColumnarReq) (*WritePreparedSeriesColumnarRes, error)
}

// UnimplementedXephonkServer can be embedded to have forward compatible implementations.
type UnimplementedXephonkServer struct {
}

func (*UnimplementedXephonkServer) Ping(ctx context.Context, req *PingReq) (*PingRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedXephonkServer) WritePoints(ctx context.Context, req *WritePointsReq) (*WritePointsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WritePoints not implemented")
}
func (*UnimplementedXephonkServer) WriteSeries(ctx context.Context, req *WriteSeriesReq) (*WriteSeriesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteSeries not implemented")
}
func (*UnimplementedXephonkServer) PrepareSeries(ctx context.Context, req *PrepareSeriesReq) (*PrepareSeriesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareSeries not implemented")
}
func (*UnimplementedXephonkServer) WritePreparedPoints(ctx context.Context, req *WritePreparedPointsReq) (*WritePreparedPointsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WritePreparedPoints not implemented")
}
func (*UnimplementedXephonkServer) WritePreparedSeries(ctx context.Context, req *WritePreparedSeriesReq) (*WritePreparedSeriesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WritePreparedSeries not implemented")
}
func (*UnimplementedXephonkServer) WritePreparedSeriesColumnar(ctx context.Context, req *WritePreparedSeriesColumnarReq) (*WritePreparedSeriesColumnarRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WritePreparedSeriesColumnar not implemented")
}

func RegisterXephonkServer(s *grpc.Server, srv XephonkServer) {
	s.RegisterService(&_Xephonk_serviceDesc, srv)
}

func _Xephonk_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XephonkServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xkrpc.Xephonk/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XephonkServer).Ping(ctx, req.(*PingReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xephonk_WritePoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WritePointsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XephonkServer).WritePoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xkrpc.Xephonk/WritePoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XephonkServer).WritePoints(ctx, req.(*WritePointsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xephonk_WriteSeries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteSeriesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XephonkServer).WriteSeries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xkrpc.Xephonk/WriteSeries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XephonkServer).WriteSeries(ctx, req.(*WriteSeriesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xephonk_PrepareSeries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareSeriesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XephonkServer).PrepareSeries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xkrpc.Xephonk/PrepareSeries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XephonkServer).PrepareSeries(ctx, req.(*PrepareSeriesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xephonk_WritePreparedPoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WritePreparedPointsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XephonkServer).WritePreparedPoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xkrpc.Xephonk/WritePreparedPoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XephonkServer).WritePreparedPoints(ctx, req.(*WritePreparedPointsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xephonk_WritePreparedSeries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WritePreparedSeriesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XephonkServer).WritePreparedSeries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xkrpc.Xephonk/WritePreparedSeries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XephonkServer).WritePreparedSeries(ctx, req.(*WritePreparedSeriesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xephonk_WritePreparedSeriesColumnar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WritePreparedSeriesColumnarReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XephonkServer).WritePreparedSeriesColumnar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xkrpc.Xephonk/WritePreparedSeriesColumnar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XephonkServer).WritePreparedSeriesColumnar(ctx, req.(*WritePreparedSeriesColumnarReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Xephonk_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xkrpc.Xephonk",
	HandlerType: (*XephonkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Xephonk_Ping_Handler,
		},
		{
			MethodName: "WritePoints",
			Handler:    _Xephonk_WritePoints_Handler,
		},
		{
			MethodName: "WriteSeries",
			Handler:    _Xephonk_WriteSeries_Handler,
		},
		{
			MethodName: "PrepareSeries",
			Handler:    _Xephonk_PrepareSeries_Handler,
		},
		{
			MethodName: "WritePreparedPoints",
			Handler:    _Xephonk_WritePreparedPoints_Handler,
		},
		{
			MethodName: "WritePreparedSeries",
			Handler:    _Xephonk_WritePreparedSeries_Handler,
		},
		{
			MethodName: "WritePreparedSeriesColumnar",
			Handler:    _Xephonk_WritePreparedSeriesColumnar_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PingRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintRpc(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WritePointsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WritePointsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WritePointsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Double) > 0 {
		for iNdEx := len(m.Double) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Double[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Int) > 0 {
		for iNdEx := len(m.Int) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Int[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WritePointsRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WritePointsRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WritePointsRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		{
			size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WriteSeriesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteSeriesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteSeriesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Double) > 0 {
		for iNdEx := len(m.Double) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Double[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Int) > 0 {
		for iNdEx := len(m.Int) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Int[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WriteSeriesRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteSeriesRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WriteSeriesRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PrepareSeriesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareSeriesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareSeriesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Series) > 0 {
		for iNdEx := len(m.Series) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Series[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PrepareSeriesRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareSeriesRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareSeriesRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Series) > 0 {
		dAtA4 := make([]byte, len(m.Series)*10)
		var j3 int
		for _, num := range m.Series {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintRpc(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreparedPointInt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreparedPointInt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreparedPointInt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.V != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.V))
		i--
		dAtA[i] = 0x18
	}
	if m.T != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.T))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PreparedPointDouble) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreparedPointDouble) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreparedPointDouble) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.V != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.V))))
		i--
		dAtA[i] = 0x19
	}
	if m.T != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.T))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRpc(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WritePreparedPointsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WritePreparedPointsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WritePreparedPointsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Double) > 0 {
		for iNdEx := len(m.Double) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Double[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Int) > 0 {
		for iNdEx := len(m.Int) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Int[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WritePreparedPointsRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WritePreparedPointsRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WritePreparedPointsRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WritePreparedSeriesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WritePreparedSeriesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WritePreparedSeriesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *WritePreparedSeriesRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WritePreparedSeriesRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WritePreparedSeriesRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WritePreparedSeriesColumnarReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WritePreparedSeriesColumnarReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WritePreparedSeriesColumnarReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *WritePreparedSeriesColumnarRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WritePreparedSeriesColumnarRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WritePreparedSeriesColumnarRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpc(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintRpc(dAtA []byte, offset int, v uint64) int {
	offset -= sovRpc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WritePointsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Int) > 0 {
		for _, e := range m.Int {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Double) > 0 {
		for _, e := range m.Double {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WritePointsRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovRpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteSeriesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Int) > 0 {
		for _, e := range m.Int {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Double) > 0 {
		for _, e := range m.Double {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteSeriesRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Error.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepareSeriesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		for _, e := range m.Series {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepareSeriesRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Series) > 0 {
		l = 0
		for _, e := range m.Series {
			l += sovRpc(uint64(e))
		}
		n += 1 + sovRpc(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreparedPointInt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRpc(uint64(m.Id))
	}
	if m.T != 0 {
		n += 1 + sovRpc(uint64(m.T))
	}
	if m.V != 0 {
		n += 1 + sovRpc(uint64(m.V))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PreparedPointDouble) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRpc(uint64(m.Id))
	}
	if m.T != 0 {
		n += 1 + sovRpc(uint64(m.T))
	}
	if m.V != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WritePreparedPointsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Int) > 0 {
		for _, e := range m.Int {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if len(m.Double) > 0 {
		for _, e := range m.Double {
			l = e.Size()
			n += 1 + l + sovRpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WritePreparedPointsRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Error.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WritePreparedSeriesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WritePreparedSeriesRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Error.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WritePreparedSeriesColumnarReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WritePreparedSeriesColumnarRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Error.Size()
	n += 1 + l + sovRpc(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRpc(x uint64) (n int) {
	return sovRpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WritePointsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WritePointsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WritePointsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int = append(m.Int, tspb.PointIntTagged{})
			if err := m.Int[len(m.Int)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Double", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Double = append(m.Double, tspb.PointDoubleTagged{})
			if err := m.Double[len(m.Double)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WritePointsRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WritePointsRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WritePointsRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteSeriesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteSeriesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteSeriesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int = append(m.Int, tspb.SeriesIntTagged{})
			if err := m.Int[len(m.Int)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Double", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Double = append(m.Double, tspb.SeriesDoubleTagged{})
			if err := m.Double[len(m.Double)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteSeriesRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteSeriesRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteSeriesRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareSeriesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareSeriesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareSeriesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Series = append(m.Series, tspb.EmptySeries{})
			if err := m.Series[len(m.Series)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareSeriesRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareSeriesRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareSeriesRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Series = append(m.Series, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Series) == 0 {
					m.Series = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Series = append(m.Series, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Series", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreparedPointInt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreparedPointInt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreparedPointInt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			m.T = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			m.V = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreparedPointDouble) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreparedPointDouble: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreparedPointDouble: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			m.T = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.V = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WritePreparedPointsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WritePreparedPointsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WritePreparedPointsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Int = append(m.Int, PreparedPointInt{})
			if err := m.Int[len(m.Int)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Double", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Double = append(m.Double, PreparedPointDouble{})
			if err := m.Double[len(m.Double)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WritePreparedPointsRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WritePreparedPointsRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WritePreparedPointsRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WritePreparedSeriesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WritePreparedSeriesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WritePreparedSeriesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WritePreparedSeriesRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WritePreparedSeriesRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WritePreparedSeriesRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WritePreparedSeriesColumnarReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WritePreparedSeriesColumnarReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WritePreparedSeriesColumnarReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WritePreparedSeriesColumnarRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WritePreparedSeriesColumnarRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WritePreparedSeriesColumnarRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRpc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRpc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRpc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRpc = fmt.Errorf("proto: unexpected end of group")
)
