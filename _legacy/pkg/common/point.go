package common

import (
	"encoding/json"
	"fmt"
	"strconv"
)

// NOTE: The following struct for point are generated by proto in common.pb.go
//  IntPoint
//  DoublePoint

// MarshalJSON implements Marshaler interface. Pointed is encoded as number array. i.e. [1359788400000,1]
// https://golang.org/pkg/encoding/json/#Marshaler
func (p *IntPoint) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("[%d,%d]", p.T, p.V)), nil
}

func (p *IntPoint) MarshalJSON2() ([]byte, error) {
	return json.Marshal([2]int64{p.T, p.V})
}

func (p *IntPoint) MarshalJSON3() ([]byte, error) {
	return []byte("[" + strconv.FormatInt(p.T, 10) + "," + strconv.FormatInt(p.V, 10) + "]"), nil
}

// UnmarshalJSON implements Unmarshaler interface
// https://golang.org/pkg/encoding/json/#Unmarshaler
func (p *IntPoint) UnmarshalJSON(data []byte) error {
	var tv [2]json.Number
	if err := json.Unmarshal(data, &tv); err != nil {
		return err
	}
	// FIXME: this error checking seems to be very low efficient
	t, err := tv[0].Int64()
	p.T = t
	if err != nil {
		return err
	}
	v, err := tv[1].Int64()
	p.V = v
	if err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements Marshaler interface. Point is encoded as number array. i.e. []
func (p *DoublePoint) MarshalJSON() ([]byte, error) {
	// TODO: precision of double value, need to copy the code in `json/encode.go`
	return []byte(fmt.Sprintf("[%d,%f]", p.T, p.V)), nil
}

// UnmarshalJSON implements Unmarshaler interface.
func (p *DoublePoint) UnmarshalJSON(data []byte) error {
	var tv [2]json.Number
	if err := json.Unmarshal(data, &tv); err != nil {
		return err
	}
	t, err := tv[0].Int64()
	if err != nil {
		return err
	}
	p.T = t
	v, err := tv[1].Float64()
	if err != nil {
		return err
	}
	p.V = v
	return nil
}
